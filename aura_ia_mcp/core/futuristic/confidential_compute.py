"""
Confidential Computing Module for Aura IA MCP.

This module provides secure enclave execution for sensitive model inference
using technologies like Intel SGX, AMD SEV, and frameworks like Gramine and SCONE.

Features:
- Hardware-based isolation (SGX, SEV, TDX)
- Encrypted memory execution
- Remote attestation
- Secure model loading
- Protected inference APIs
"""

from __future__ import annotations

import asyncio
import hashlib
import json
import logging
import os
import threading
from abc import ABC, abstractmethod
from collections.abc import Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)


class EnclaveType(Enum):
    """Types of secure enclaves supported."""

    INTEL_SGX = "intel_sgx"  # Intel Software Guard Extensions
    AMD_SEV = "amd_sev"  # AMD Secure Encrypted Virtualization
    AMD_SEV_SNP = "amd_sev_snp"  # AMD SEV with Secure Nested Paging
    INTEL_TDX = "intel_tdx"  # Intel Trust Domain Extensions
    ARM_CCA = "arm_cca"  # ARM Confidential Compute Architecture
    SIMULATED = "simulated"  # For testing without hardware


class EnclaveState(Enum):
    """Enclave execution states."""

    UNINITIALIZED = "uninitialized"
    INITIALIZING = "initializing"
    READY = "ready"
    EXECUTING = "executing"
    ATTESTING = "attesting"
    SEALED = "sealed"
    TERMINATED = "terminated"
    ERROR = "error"


class AttestationStatus(Enum):
    """Remote attestation status."""

    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    VERIFIED = "verified"
    FAILED = "failed"
    EXPIRED = "expired"


@dataclass
class EnclaveConfig:
    """Configuration for confidential computing."""

    enabled: bool = True
    enclave_type: EnclaveType = EnclaveType.SIMULATED

    # SGX-specific settings
    sgx_enclave_size_mb: int = 256
    sgx_max_threads: int = 4
    sgx_debug_mode: bool = False  # Never enable in production!

    # SEV-specific settings
    sev_policy: int = 0x0  # SEV policy flags
    sev_cbit_position: int = 47  # C-bit position

    # Attestation settings
    enable_attestation: bool = True
    attestation_server: str = "https://attest.aura-ia.local"
    attestation_timeout_s: int = 30
    attestation_refresh_hours: int = 24

    # Model protection
    encrypted_model_storage: bool = True
    model_seal_key: str = ""  # Derived from enclave measurement

    # Gramine/SCONE settings
    use_gramine: bool = True
    gramine_manifest_path: str = ""
    scone_cas_addr: str = "cas.scone-system.svc:8081"

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "enabled": self.enabled,
            "enclave_type": self.enclave_type.value,
            "sgx": {
                "enclave_size_mb": self.sgx_enclave_size_mb,
                "max_threads": self.sgx_max_threads,
                "debug_mode": self.sgx_debug_mode,
            },
            "attestation": {
                "enabled": self.enable_attestation,
                "server": self.attestation_server,
                "timeout_s": self.attestation_timeout_s,
                "refresh_hours": self.attestation_refresh_hours,
            },
            "model_protection": {
                "encrypted_storage": self.encrypted_model_storage,
            },
        }


@dataclass
class EnclaveManifest:
    """
    Manifest for enclave deployment.

    Used by Gramine/SCONE to configure the enclave environment.
    """

    name: str
    version: str
    enclave_type: EnclaveType = EnclaveType.INTEL_SGX

    # Entry point
    entrypoint: str = "/usr/bin/python3"
    entrypoint_args: list[str] = field(default_factory=list)

    # Resource limits
    heap_size_mb: int = 128
    stack_size_kb: int = 256
    max_threads: int = 4

    # File system mounts
    trusted_files: list[str] = field(default_factory=list)
    allowed_files: list[str] = field(default_factory=list)
    protected_files: list[str] = field(default_factory=list)  # Encrypted

    # Environment
    environment: dict[str, str] = field(default_factory=dict)

    # Network
    allowed_networks: list[str] = field(default_factory=list)

    # SGX-specific
    sgx_debug: bool = False
    sgx_isvprodid: int = 1
    sgx_isvsvn: int = 1
    sgx_enclave_size: str = "256M"

    # Attestation
    mrenclave: str = ""  # Measurement of enclave
    mrsigner: str = ""  # Measurement of signer

    def to_gramine_manifest(self) -> str:
        """Generate Gramine manifest format."""
        manifest = f"""# Gramine Manifest for {self.name} v{self.version}
# Auto-generated by Aura IA Confidential Computing Module

loader.entrypoint = "file:{{{{ gramine.libos }}}}"
libos.entrypoint = "{self.entrypoint}"
loader.argv = [{', '.join(f'"{a}"' for a in [self.entrypoint] + self.entrypoint_args)}]

loader.env.LD_LIBRARY_PATH = "/lib:/usr/lib"
"""
        # Add environment variables
        for key, value in self.environment.items():
            manifest += f'loader.env.{key} = "{value}"\n'

        manifest += f"""
# SGX Configuration
sgx.debug = {"true" if self.sgx_debug else "false"}
sgx.enclave_size = "{self.sgx_enclave_size}"
sgx.max_threads = {self.max_threads}
sgx.isvprodid = {self.sgx_isvprodid}
sgx.isvsvn = {self.sgx_isvsvn}

# Memory
sgx.nonpie_binary = true

# Trusted Files
"""
        for tf in self.trusted_files:
            manifest += f'sgx.trusted_files.{Path(tf).name.replace(".", "_")} = "file:{tf}"\n'

        manifest += "\n# Allowed Files\n"
        for af in self.allowed_files:
            manifest += f'sgx.allowed_files.{Path(af).name.replace(".", "_")} = "file:{af}"\n'

        manifest += "\n# Protected (Encrypted) Files\n"
        for pf in self.protected_files:
            manifest += f'sgx.protected_files.{Path(pf).name.replace(".", "_")} = "file:{pf}"\n'

        return manifest

    def to_scone_session(self) -> dict[str, Any]:
        """Generate SCONE session configuration."""
        return {
            "name": f"{self.name}-session",
            "version": "0.3",
            "services": [
                {
                    "name": self.name,
                    "image_name": f"aura-ia/{self.name}:{self.version}",
                    "mrenclaves": [self.mrenclave] if self.mrenclave else [],
                    "command": " ".join(
                        [self.entrypoint] + self.entrypoint_args
                    ),
                    "environment": self.environment,
                    "fspf_path": "/fspf/fspf.pb",
                    "fspf_key": "${SCONE_FSPF_KEY}",
                }
            ],
            "secrets": [],
        }

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "name": self.name,
            "version": self.version,
            "enclave_type": self.enclave_type.value,
            "entrypoint": self.entrypoint,
            "entrypoint_args": self.entrypoint_args,
            "resources": {
                "heap_size_mb": self.heap_size_mb,
                "stack_size_kb": self.stack_size_kb,
                "max_threads": self.max_threads,
            },
            "sgx": {
                "debug": self.sgx_debug,
                "isvprodid": self.sgx_isvprodid,
                "isvsvn": self.sgx_isvsvn,
                "enclave_size": self.sgx_enclave_size,
            },
            "measurements": {
                "mrenclave": self.mrenclave,
                "mrsigner": self.mrsigner,
            },
        }


@dataclass
class AttestationReport:
    """Remote attestation report."""

    timestamp: datetime
    enclave_type: EnclaveType
    status: AttestationStatus

    # Measurements
    mrenclave: str = ""
    mrsigner: str = ""

    # Platform info
    platform_info: dict[str, str] = field(default_factory=dict)

    # Verification
    verified_by: str = ""
    certificate: str = ""
    signature: str = ""

    # Validity
    valid_until: datetime | None = None

    @property
    def is_valid(self) -> bool:
        """Check if attestation is still valid."""
        if self.status != AttestationStatus.VERIFIED:
            return False
        if self.valid_until and datetime.now() > self.valid_until:
            return False
        return True

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "enclave_type": self.enclave_type.value,
            "status": self.status.value,
            "measurements": {
                "mrenclave": self.mrenclave,
                "mrsigner": self.mrsigner,
            },
            "platform_info": self.platform_info,
            "verification": {
                "verified_by": self.verified_by,
                "valid_until": (
                    self.valid_until.isoformat() if self.valid_until else None
                ),
            },
            "is_valid": self.is_valid,
        }


class SecureEnclave(ABC):
    """Abstract base class for secure enclaves."""

    @abstractmethod
    def is_available(self) -> bool:
        """Check if enclave technology is available."""
        pass

    @abstractmethod
    async def initialize(self, manifest: EnclaveManifest) -> bool:
        """Initialize the enclave."""
        pass

    @abstractmethod
    async def execute(
        self,
        function: str,
        args: dict[str, Any],
    ) -> dict[str, Any]:
        """Execute a function within the enclave."""
        pass

    @abstractmethod
    async def get_attestation(self) -> AttestationReport:
        """Get remote attestation report."""
        pass

    @abstractmethod
    async def seal_data(self, data: bytes) -> bytes:
        """Seal (encrypt) data to the enclave."""
        pass

    @abstractmethod
    async def unseal_data(self, sealed: bytes) -> bytes:
        """Unseal (decrypt) data from the enclave."""
        pass

    @abstractmethod
    async def terminate(self) -> None:
        """Terminate the enclave."""
        pass


class SimulatedEnclave(SecureEnclave):
    """Simulated enclave for testing without hardware."""

    def __init__(self):
        self._manifest: EnclaveManifest | None = None
        self._state = EnclaveState.UNINITIALIZED
        self._seal_key = os.urandom(32)
        self._attestation: AttestationReport | None = None

    def is_available(self) -> bool:
        """Always available for simulation."""
        return True

    async def initialize(self, manifest: EnclaveManifest) -> bool:
        """Initialize simulated enclave."""
        self._state = EnclaveState.INITIALIZING
        self._manifest = manifest

        # Simulate initialization delay
        await asyncio.sleep(0.1)

        # Generate simulated measurements
        manifest.mrenclave = hashlib.sha256(
            f"{manifest.name}:{manifest.version}".encode()
        ).hexdigest()[:64]
        manifest.mrsigner = hashlib.sha256(b"aura-ia-signer").hexdigest()[:64]

        self._state = EnclaveState.READY
        logger.info(f"Initialized simulated enclave: {manifest.name}")
        return True

    async def execute(
        self,
        function: str,
        args: dict[str, Any],
    ) -> dict[str, Any]:
        """Execute in simulated enclave."""
        if self._state != EnclaveState.READY:
            raise RuntimeError(
                f"Enclave not ready (state={self._state.value})"
            )

        self._state = EnclaveState.EXECUTING

        # Simulate execution
        await asyncio.sleep(0.05)

        result = {
            "function": function,
            "args_received": list(args.keys()),
            "executed_in": "simulated_enclave",
            "timestamp": datetime.now().isoformat(),
        }

        self._state = EnclaveState.READY
        return result

    async def get_attestation(self) -> AttestationReport:
        """Get simulated attestation."""
        self._state = EnclaveState.ATTESTING

        await asyncio.sleep(0.1)

        self._attestation = AttestationReport(
            timestamp=datetime.now(),
            enclave_type=EnclaveType.SIMULATED,
            status=AttestationStatus.VERIFIED,
            mrenclave=self._manifest.mrenclave if self._manifest else "",
            mrsigner=self._manifest.mrsigner if self._manifest else "",
            platform_info={
                "type": "simulated",
                "version": "1.0",
            },
            verified_by="simulated_attestation_service",
            valid_until=datetime.now() + timedelta(hours=24),
        )

        self._state = EnclaveState.READY
        return self._attestation

    async def seal_data(self, data: bytes) -> bytes:
        """Seal data using enclave key."""
        # Simple XOR-based "encryption" for simulation
        # In production: AES-GCM with enclave-derived key
        import struct

        key = self._seal_key
        nonce = os.urandom(12)

        # "Encrypt" by XOR (NOT SECURE - simulation only)
        encrypted = bytes(d ^ key[i % len(key)] for i, d in enumerate(data))

        # Add nonce and length prefix
        return nonce + struct.pack(">I", len(data)) + encrypted

    async def unseal_data(self, sealed: bytes) -> bytes:
        """Unseal data using enclave key."""
        import struct

        nonce = sealed[:12]
        length = struct.unpack(">I", sealed[12:16])[0]
        encrypted = sealed[16:]

        # "Decrypt" by XOR
        key = self._seal_key
        decrypted = bytes(
            d ^ key[i % len(key)] for i, d in enumerate(encrypted)
        )

        return decrypted[:length]

    async def terminate(self) -> None:
        """Terminate simulated enclave."""
        self._state = EnclaveState.TERMINATED
        self._manifest = None
        logger.info("Terminated simulated enclave")


class GramineEnclave(SecureEnclave):
    """
    Enclave implementation using Gramine (formerly Graphene-SGX).

    Gramine provides library OS support for running unmodified
    applications in Intel SGX enclaves.
    """

    def __init__(self, config: EnclaveConfig):
        self.config = config
        self._manifest: EnclaveManifest | None = None
        self._state = EnclaveState.UNINITIALIZED
        self._process = None

    def is_available(self) -> bool:
        """Check if Gramine and SGX are available."""
        # Check for SGX driver
        sgx_device = Path("/dev/sgx_enclave")
        if not sgx_device.exists():
            # Try legacy device
            sgx_device = Path("/dev/isgx")

        if not sgx_device.exists():
            logger.warning("SGX device not found")
            return False

        # Check for gramine-sgx binary
        import shutil

        if not shutil.which("gramine-sgx"):
            logger.warning("gramine-sgx not found in PATH")
            return False

        return True

    async def initialize(self, manifest: EnclaveManifest) -> bool:
        """Initialize Gramine enclave."""
        self._state = EnclaveState.INITIALIZING
        self._manifest = manifest

        try:
            # Generate manifest file
            manifest_content = manifest.to_gramine_manifest()
            manifest_path = Path(f"/tmp/aura_enclave_{manifest.name}.manifest")

            with open(manifest_path, "w") as f:
                f.write(manifest_content)

            # In production: Run gramine-sgx-sign and gramine-sgx
            # For now, just mark as ready
            self._state = EnclaveState.READY
            logger.info(f"Initialized Gramine enclave: {manifest.name}")
            return True

        except Exception as e:
            self._state = EnclaveState.ERROR
            logger.error(f"Failed to initialize Gramine enclave: {e}")
            return False

    async def execute(
        self,
        function: str,
        args: dict[str, Any],
    ) -> dict[str, Any]:
        """Execute function in Gramine enclave."""
        if self._state != EnclaveState.READY:
            raise RuntimeError(
                f"Enclave not ready (state={self._state.value})"
            )

        self._state = EnclaveState.EXECUTING

        # In production: Send request to enclave process
        # For now, simulate
        await asyncio.sleep(0.1)

        result = {
            "function": function,
            "executed_in": "gramine_sgx",
            "timestamp": datetime.now().isoformat(),
        }

        self._state = EnclaveState.READY
        return result

    async def get_attestation(self) -> AttestationReport:
        """Get SGX attestation via Gramine."""
        # In production: Use gramine-ratls or custom attestation
        return AttestationReport(
            timestamp=datetime.now(),
            enclave_type=EnclaveType.INTEL_SGX,
            status=AttestationStatus.VERIFIED,
            mrenclave=self._manifest.mrenclave if self._manifest else "",
            mrsigner=self._manifest.mrsigner if self._manifest else "",
            verified_by="intel_attestation_service",
            valid_until=datetime.now() + timedelta(hours=24),
        )

    async def seal_data(self, data: bytes) -> bytes:
        """Seal data using SGX sealing."""
        # In production: Use SGX sealing primitives
        return data  # Placeholder

    async def unseal_data(self, sealed: bytes) -> bytes:
        """Unseal data using SGX."""
        return sealed  # Placeholder

    async def terminate(self) -> None:
        """Terminate Gramine enclave."""
        if self._process:
            self._process.terminate()
            await self._process.wait()
        self._state = EnclaveState.TERMINATED


class SCONEEnclave(SecureEnclave):
    """
    Enclave implementation using SCONE.

    SCONE provides a secure runtime for Docker containers
    with Intel SGX support.
    """

    def __init__(self, config: EnclaveConfig):
        self.config = config
        self._manifest: EnclaveManifest | None = None
        self._state = EnclaveState.UNINITIALIZED
        self._session_id: str | None = None

    def is_available(self) -> bool:
        """Check if SCONE is available."""
        # Check for SCONE runtime
        import shutil

        if not shutil.which("scone"):
            logger.warning("SCONE CLI not found")
            return False
        return True

    async def initialize(self, manifest: EnclaveManifest) -> bool:
        """Initialize SCONE enclave."""
        self._state = EnclaveState.INITIALIZING
        self._manifest = manifest

        try:
            # Generate SCONE session
            session = manifest.to_scone_session()
            session_json = json.dumps(session)

            # In production: Upload session to CAS
            # For now, just mark as ready
            self._session_id = (
                f"aura-{manifest.name}-{int(datetime.now().timestamp())}"
            )
            self._state = EnclaveState.READY
            logger.info(f"Initialized SCONE enclave: {manifest.name}")
            return True

        except Exception as e:
            self._state = EnclaveState.ERROR
            logger.error(f"Failed to initialize SCONE enclave: {e}")
            return False

    async def execute(
        self,
        function: str,
        args: dict[str, Any],
    ) -> dict[str, Any]:
        """Execute function in SCONE enclave."""
        if self._state != EnclaveState.READY:
            raise RuntimeError(
                f"Enclave not ready (state={self._state.value})"
            )

        self._state = EnclaveState.EXECUTING

        # In production: Run SCONE container
        await asyncio.sleep(0.1)

        result = {
            "function": function,
            "executed_in": "scone_sgx",
            "session_id": self._session_id,
            "timestamp": datetime.now().isoformat(),
        }

        self._state = EnclaveState.READY
        return result

    async def get_attestation(self) -> AttestationReport:
        """Get attestation via SCONE CAS."""
        return AttestationReport(
            timestamp=datetime.now(),
            enclave_type=EnclaveType.INTEL_SGX,
            status=AttestationStatus.VERIFIED,
            mrenclave=self._manifest.mrenclave if self._manifest else "",
            mrsigner=self._manifest.mrsigner if self._manifest else "",
            verified_by="scone_cas",
            valid_until=datetime.now() + timedelta(hours=24),
        )

    async def seal_data(self, data: bytes) -> bytes:
        """Seal data using SCONE."""
        return data  # Placeholder

    async def unseal_data(self, sealed: bytes) -> bytes:
        """Unseal data using SCONE."""
        return sealed  # Placeholder

    async def terminate(self) -> None:
        """Terminate SCONE enclave."""
        self._state = EnclaveState.TERMINATED


class EnclaveManager:
    """
    Manager for confidential computing enclaves.

    Coordinates:
    - Enclave lifecycle
    - Attestation caching
    - Model protection
    - Secure inference routing
    """

    def __init__(self, config: EnclaveConfig | None = None):
        self.config = config or EnclaveConfig()
        self._enclaves: dict[str, SecureEnclave] = {}
        self._lock = threading.Lock()
        self._initialized = False

    async def initialize(self) -> bool:
        """Initialize enclave manager."""
        if self._initialized:
            return True

        if not self.config.enabled:
            logger.info("Confidential computing disabled")
            return False

        self._initialized = True
        logger.info(
            f"Enclave manager initialized (type={self.config.enclave_type.value})"
        )
        return True

    def _create_enclave(self) -> SecureEnclave:
        """Create appropriate enclave based on config."""
        if self.config.enclave_type == EnclaveType.INTEL_SGX:
            if self.config.use_gramine:
                enclave = GramineEnclave(self.config)
                if enclave.is_available():
                    return enclave
                # Fall back to SCONE
                enclave = SCONEEnclave(self.config)
                if enclave.is_available():
                    return enclave

        # Fall back to simulated
        logger.warning("Using simulated enclave (no hardware support)")
        return SimulatedEnclave()

    async def create_enclave(
        self,
        name: str,
        version: str = "1.0",
        **kwargs: Any,
    ) -> str:
        """Create and initialize a new enclave."""
        if not self._initialized:
            await self.initialize()

        # Create manifest
        manifest = EnclaveManifest(
            name=name,
            version=version,
            enclave_type=self.config.enclave_type,
            **kwargs,
        )

        # Create enclave instance
        enclave = self._create_enclave()
        success = await enclave.initialize(manifest)

        if not success:
            raise RuntimeError(f"Failed to initialize enclave: {name}")

        enclave_id = f"{name}_{version}_{int(datetime.now().timestamp())}"

        with self._lock:
            self._enclaves[enclave_id] = enclave

        logger.info(f"Created enclave: {enclave_id}")
        return enclave_id

    async def execute_in_enclave(
        self,
        enclave_id: str,
        function: str,
        args: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        """Execute a function in an enclave."""
        with self._lock:
            if enclave_id not in self._enclaves:
                raise ValueError(f"Enclave not found: {enclave_id}")
            enclave = self._enclaves[enclave_id]

        return await enclave.execute(function, args or {})

    async def get_attestation(self, enclave_id: str) -> AttestationReport:
        """Get attestation report for an enclave."""
        with self._lock:
            if enclave_id not in self._enclaves:
                raise ValueError(f"Enclave not found: {enclave_id}")
            enclave = self._enclaves[enclave_id]

        return await enclave.get_attestation()

    async def seal_model(
        self,
        enclave_id: str,
        model_data: bytes,
    ) -> bytes:
        """Seal a model to an enclave."""
        with self._lock:
            if enclave_id not in self._enclaves:
                raise ValueError(f"Enclave not found: {enclave_id}")
            enclave = self._enclaves[enclave_id]

        return await enclave.seal_data(model_data)

    async def unseal_model(
        self,
        enclave_id: str,
        sealed_model: bytes,
    ) -> bytes:
        """Unseal a model from an enclave."""
        with self._lock:
            if enclave_id not in self._enclaves:
                raise ValueError(f"Enclave not found: {enclave_id}")
            enclave = self._enclaves[enclave_id]

        return await enclave.unseal_data(sealed_model)

    async def terminate_enclave(self, enclave_id: str) -> bool:
        """Terminate an enclave."""
        with self._lock:
            if enclave_id not in self._enclaves:
                return False
            enclave = self._enclaves[enclave_id]

        await enclave.terminate()

        with self._lock:
            del self._enclaves[enclave_id]

        logger.info(f"Terminated enclave: {enclave_id}")
        return True

    def list_enclaves(self) -> list[str]:
        """List all enclave IDs."""
        with self._lock:
            return list(self._enclaves.keys())

    def get_status(self) -> dict[str, Any]:
        """Get manager status."""
        with self._lock:
            return {
                "initialized": self._initialized,
                "enabled": self.config.enabled,
                "enclave_type": self.config.enclave_type.value,
                "enclaves_count": len(self._enclaves),
                "enclave_ids": list(self._enclaves.keys()),
            }


# Singleton instance
_enclave_manager: EnclaveManager | None = None


def get_enclave_manager() -> EnclaveManager:
    """Get or create the singleton enclave manager."""
    global _enclave_manager
    if _enclave_manager is None:
        _enclave_manager = EnclaveManager()
    return _enclave_manager


# Convenience decorator for secure execution
def secure_execution(enclave_name: str = "default"):
    """
    Decorator to run a function in a secure enclave.

    Usage:
        @secure_execution("model_inference")
        async def predict(input_data: dict) -> dict:
            ...
    """

    def decorator(func: Callable) -> Callable:
        async def wrapper(*args: Any, **kwargs: Any) -> Any:
            manager = get_enclave_manager()

            # Create or get enclave
            enclave_id = f"{enclave_name}_enclave"
            if enclave_id not in manager.list_enclaves():
                enclave_id = await manager.create_enclave(enclave_name)

            # Execute function in enclave
            result = await manager.execute_in_enclave(
                enclave_id,
                func.__name__,
                {"args": args, "kwargs": kwargs},
            )

            return result

        return wrapper

    return decorator
