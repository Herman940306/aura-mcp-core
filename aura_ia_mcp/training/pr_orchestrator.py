"""PR Orchestrator for autonomous code improvement proposals."""

import hashlib
import logging
import os
from dataclasses import dataclass
from datetime import datetime
from typing import Any

import httpx

logger = logging.getLogger(__name__)


@dataclass
class CodeChange:
    """Represents a single code change."""

    file_path: str
    original_content: str | None
    new_content: str
    change_type: str  # "create", "update", "delete"
    rationale: str


@dataclass
class PRProposal:
    """Structured PR proposal."""

    title: str
    body: str
    branch_name: str
    changes: list[CodeChange]
    metadata: dict[str, Any]
    created_at: str
    proposal_id: str


class PROrchestrator:
    """Orchestrates PR creation with GitHub integration."""

    def __init__(
        self,
        github_token: str | None = None,
        repo_owner: str = "",
        repo_name: str = "",
    ):
        self.github_token = github_token or os.getenv("GITHUB_TOKEN")
        self.repo_owner = repo_owner
        self.repo_name = repo_name
        self.github_api = "https://api.github.com"

    def generate_proposal(
        self,
        changes: list[dict[str, Any]],
        title: str,
        description: str,
        run_id: str | None = None,
    ) -> PRProposal:
        """Generate a structured PR proposal from changes.

        Args:
            changes: List of code changes with file_path, content, type, rationale
            title: PR title
            description: PR description
            run_id: Optional training run identifier

        Returns:
            PRProposal with all structured data
        """
        timestamp = datetime.utcnow().isoformat()
        proposal_id = hashlib.sha256(
            f"{timestamp}{title}".encode()
        ).hexdigest()[:12]

        # Convert dict changes to CodeChange objects
        code_changes = [
            CodeChange(
                file_path=ch.get("file_path", ""),
                original_content=ch.get("original_content"),
                new_content=ch.get("new_content", ""),
                change_type=ch.get("change_type", "update"),
                rationale=ch.get("rationale", "No rationale provided"),
            )
            for ch in changes
        ]

        # Generate branch name
        branch_name = f"aura-sicd/{proposal_id}"

        # Build comprehensive PR body
        pr_body = self._build_pr_body(description, code_changes, run_id)

        return PRProposal(
            title=title,
            body=pr_body,
            branch_name=branch_name,
            changes=code_changes,
            metadata={
                "run_id": run_id,
                "change_count": len(code_changes),
                "change_types": {ch.change_type for ch in code_changes},
            },
            created_at=timestamp,
            proposal_id=proposal_id,
        )

    def _build_pr_body(
        self, description: str, changes: list[CodeChange], run_id: str | None
    ) -> str:
        """Build detailed PR body with change summary."""
        lines = [
            "## Autonomous Code Improvement Proposal",
            "",
            description,
            "",
            "### Changes Summary",
            "",
        ]

        for change in changes:
            lines.append(
                f"- **{change.change_type.upper()}**: `{change.file_path}`"
            )
            lines.append(f"  - {change.rationale}")
            lines.append("")

        if run_id:
            lines.extend(["", f"**Training Run ID**: `{run_id}`", ""])

        lines.extend(
            [
                "---",
                "*Generated by Aura IA MCP SICD Training Loop*",
            ]
        )

        return "\n".join(lines)

    async def create_github_pr(
        self,
        proposal: PRProposal,
        base_branch: str = "main",
        dry_run: bool = False,
    ) -> dict[str, Any]:
        """Create actual GitHub PR via API.

        Args:
            proposal: PR proposal with all changes
            base_branch: Target branch (default: main)
            dry_run: If True, simulate without actual API calls

        Returns:
            Result dict with status and PR URL (if created)
        """
        if dry_run:
            logger.info(
                f"DRY RUN: Would create PR '{proposal.title}' with {len(proposal.changes)} changes"
            )
            return {
                "status": "dry_run",
                "proposal_id": proposal.proposal_id,
                "branch": proposal.branch_name,
                "changes": len(proposal.changes),
            }

        if not self.github_token:
            logger.warning("No GITHUB_TOKEN configured, cannot create PR")
            return {"status": "error", "reason": "GITHUB_TOKEN not configured"}

        if not self.repo_owner or not self.repo_name:
            logger.warning(
                "Repository not configured (repo_owner/repo_name required)"
            )
            return {"status": "error", "reason": "Repository not configured"}

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                # Step 1: Get base branch SHA
                ref_url = f"{self.github_api}/repos/{self.repo_owner}/{self.repo_name}/git/ref/heads/{base_branch}"
                headers = {
                    "Authorization": f"token {self.github_token}",
                    "Accept": "application/vnd.github.v3+json",
                }

                ref_resp = await client.get(ref_url, headers=headers)
                if ref_resp.status_code != 200:
                    logger.error(f"Failed to get base branch: {ref_resp.text}")
                    return {
                        "status": "error",
                        "reason": f"Base branch not found: {base_branch}",
                    }

                base_sha = ref_resp.json()["object"]["sha"]

                # Step 2: Create new branch
                create_ref_url = f"{self.github_api}/repos/{self.repo_owner}/{self.repo_name}/git/refs"
                create_ref_payload = {
                    "ref": f"refs/heads/{proposal.branch_name}",
                    "sha": base_sha,
                }

                ref_create_resp = await client.post(
                    create_ref_url, headers=headers, json=create_ref_payload
                )
                if ref_create_resp.status_code not in (
                    201,
                    422,
                ):  # 422 = already exists
                    logger.error(
                        f"Failed to create branch: {ref_create_resp.text}"
                    )
                    return {
                        "status": "error",
                        "reason": "Failed to create branch",
                    }

                # Step 3: Commit changes to new branch
                for change in proposal.changes:
                    if change.change_type == "delete":
                        continue  # Skip deletes for now (requires different API)

                    file_url = f"{self.github_api}/repos/{self.repo_owner}/{self.repo_name}/contents/{change.file_path}"
                    file_payload = {
                        "message": f"Update {change.file_path}: {change.rationale}",
                        "content": change.new_content,  # Base64 encode in production
                        "branch": proposal.branch_name,
                    }

                    # Get current file SHA if updating
                    if change.change_type == "update":
                        get_resp = await client.get(
                            f"{file_url}?ref={proposal.branch_name}",
                            headers=headers,
                        )
                        if get_resp.status_code == 200:
                            file_payload["sha"] = get_resp.json()["sha"]

                    file_resp = await client.put(
                        file_url, headers=headers, json=file_payload
                    )
                    if file_resp.status_code not in (200, 201):
                        logger.warning(
                            f"Failed to commit {change.file_path}: {file_resp.text}"
                        )

                # Step 4: Create pull request
                pr_url = f"{self.github_api}/repos/{self.repo_owner}/{self.repo_name}/pulls"
                pr_payload = {
                    "title": proposal.title,
                    "body": proposal.body,
                    "head": proposal.branch_name,
                    "base": base_branch,
                }

                pr_resp = await client.post(
                    pr_url, headers=headers, json=pr_payload
                )
                if pr_resp.status_code == 201:
                    pr_data = pr_resp.json()
                    logger.info(
                        f"Created PR #{pr_data['number']}: {pr_data['html_url']}"
                    )
                    return {
                        "status": "created",
                        "pr_number": pr_data["number"],
                        "pr_url": pr_data["html_url"],
                        "proposal_id": proposal.proposal_id,
                    }
                else:
                    logger.error(f"Failed to create PR: {pr_resp.text}")
                    return {
                        "status": "error",
                        "reason": "Failed to create PR",
                        "detail": pr_resp.text,
                    }

        except Exception as e:
            logger.exception("Error creating GitHub PR")
            return {"status": "error", "reason": str(e)}


def propose_pr(
    changes: list,
    title: str = "Autonomous Code Improvement",
    description: str = "",
) -> dict:
    """Legacy function for backward compatibility.

    Args:
        changes: List of code changes
        title: PR title
        description: PR description

    Returns:
        Dict with proposal data
    """
    orchestrator = PROrchestrator()
    proposal = orchestrator.generate_proposal(changes, title, description)
    return {
        "proposal_id": proposal.proposal_id,
        "title": proposal.title,
        "branch": proposal.branch_name,
        "changes": len(proposal.changes),
        "approved": False,
        "created_at": proposal.created_at,
    }
